import { existsSync } from 'node:fs';
import { mkdir } from 'node:fs/promises';
import { join } from 'node:path';
import {
	IndentationText,
	NewLineKind,
	Project,
	QuoteKind,
	VariableDeclarationKind,
} from 'ts-morph';
import type { NextJsProjectAnalysis, TransformedRoute } from './types.js';

/**
 * Generate test stubs for all migrated routes
 */
export async function generateTestStubs(
	analysis: NextJsProjectAnalysis,
	outputDir: string,
	transformedRoutes?: TransformedRoute[],
): Promise<string[]> {
	const testDir = join(outputDir, 'tests/routes');

	if (!existsSync(testDir)) {
		await mkdir(testDir, { recursive: true });
	}

	const createdFiles: string[] = [];
	const routes = transformedRoutes ?? analysis.routes;

	// Generate test file for each route group
	const routeGroups = groupRoutesByBase(routes);

	for (const [baseName, groupRoutes] of Object.entries(routeGroups)) {
		const testPath = join(testDir, `${baseName}.test.ts`);
		await generateTestFile(testPath, baseName, groupRoutes);
		createdFiles.push(testPath);
	}

	// Generate test setup file
	const setupPath = join(outputDir, 'tests/setup.ts');
	await generateTestSetup(setupPath);
	createdFiles.push(setupPath);

	return createdFiles;
}

/**
 * Group routes by their base path for organizing tests
 */
function groupRoutesByBase(
	routes: Array<{ elysiaPath: string; methods?: string[]; handlers?: Array<{ method: string }> }>,
): Record<string, Array<{ elysiaPath: string; methods: string[] }>> {
	const groups: Record<string, Array<{ elysiaPath: string; methods: string[] }>> = {};

	for (const route of routes) {
		const path = route.elysiaPath;
		const parts = path.split('/').filter(Boolean);
		const baseName = parts[0] || 'root';

		if (!groups[baseName]) {
			groups[baseName] = [];
		}

		const methods =
			route.methods || (route.handlers ? route.handlers.map((h) => h.method) : ['GET']);

		groups[baseName].push({
			elysiaPath: path,
			methods,
		});
	}

	return groups;
}

/**
 * Generate a test file for a route group
 */
async function generateTestFile(
	outputPath: string,
	baseName: string,
	routes: Array<{ elysiaPath: string; methods: string[] }>,
): Promise<void> {
	const project = new Project({
		manipulationSettings: {
			indentationText: IndentationText.TwoSpaces,
			newLineKind: NewLineKind.LineFeed,
			quoteKind: QuoteKind.Double,
			usePrefixAndSuffixTextForRename: false,
			useTrailingCommas: true,
		},
	});

	const sourceFile = project.createSourceFile(outputPath, '', {
		overwrite: true,
	});

	// Add header comment
	sourceFile.addStatements(`/**
 * Tests for ${baseName} routes
 * 
 * Generated by Foxen migration tool.
 * TODO: Fill in assertions based on your API behavior.
 */
`);

	// Add imports
	sourceFile.addImportDeclaration({
		moduleSpecifier: 'bun:test',
		namedImports: ['describe', 'test', 'expect', 'beforeAll', 'afterAll'],
	});

	sourceFile.addImportDeclaration({
		moduleSpecifier: '@elysiajs/eden',
		namedImports: ['treaty'],
	});

	sourceFile.addImportDeclaration({
		moduleSpecifier: '../src/generated',
		namedImports: [{ name: 'App', isTypeOnly: true }],
	});

	sourceFile.addStatements('\n');

	// Add treaty client setup
	sourceFile.addVariableStatement({
		declarationKind: VariableDeclarationKind.Const,
		declarations: [
			{
				name: 'api',
				initializer: 'treaty<App>("http://localhost:3000")',
			},
		],
	});

	sourceFile.addStatements('\n');

	// Generate describe block for each route
	const describeContent = generateDescribeContent(baseName, routes);
	sourceFile.addStatements(describeContent);

	await sourceFile.save();
}

/**
 * Generate describe block content for routes
 */
function generateDescribeContent(
	baseName: string,
	routes: Array<{ elysiaPath: string; methods: string[] }>,
): string {
	const tests: string[] = [];

	for (const route of routes) {
		for (const method of route.methods) {
			const testName = `${method} ${route.elysiaPath}`;
			const methodLower = method.toLowerCase();
			const pathParts = route.elysiaPath
				.split('/')
				.filter((p) => p && !p.startsWith(':') && !p.startsWith('*'));
			const edenPath = pathParts.join('.');

			// Determine if this method typically needs a body
			const needsBody = ['POST', 'PUT', 'PATCH'].includes(method);

			let testBody: string;
			if (needsBody) {
				testBody = `
    test("${testName}", async () => {
      // TODO: Replace with actual test data
      const payload = {};
      
      const { data, status, error } = await api${edenPath ? `.${edenPath}` : ''}.${methodLower}(payload);
      
      expect(status).toBe(200);
      expect(error).toBeNull();
      // TODO: Add assertions for response data
      // expect(data).toMatchObject({});
    });`;
			} else {
				testBody = `
    test("${testName}", async () => {
      const { data, status, error } = await api${edenPath ? `.${edenPath}` : ''}.${methodLower}();
      
      expect(status).toBe(200);
      expect(error).toBeNull();
      // TODO: Add assertions for response data
      // expect(data).toMatchObject({});
    });`;
			}

			tests.push(testBody);
		}
	}

	return `describe("${baseName} routes", () => {
  // TODO: Add any setup/teardown if needed
  // beforeAll(async () => {});
  // afterAll(async () => {});
${tests.join('\n')}
});`;
}

/**
 * Generate test setup file
 */
async function generateTestSetup(outputPath: string): Promise<void> {
	const project = new Project({
		manipulationSettings: {
			indentationText: IndentationText.TwoSpaces,
			newLineKind: NewLineKind.LineFeed,
			quoteKind: QuoteKind.Double,
			usePrefixAndSuffixTextForRename: false,
			useTrailingCommas: true,
		},
	});

	const sourceFile = project.createSourceFile(outputPath, '', {
		overwrite: true,
	});

	sourceFile.addStatements(`/**
 * Test setup file
 * 
 * This file sets up the test environment.
 * You can start your server here or use a test database.
 */

import { beforeAll, afterAll } from "bun:test";
import { app } from "../src";

let server: ReturnType<typeof app.listen> | null = null;

beforeAll(async () => {
  // Start the server for testing
  // Uncomment if you want to start the server automatically
  // server = app.listen(3000);
  // console.log("Test server started on port 3000");
});

afterAll(async () => {
  // Stop the server after tests
  if (server) {
    // server.stop();
    // console.log("Test server stopped");
  }
});

export { app };
`);

	await sourceFile.save();
}
