import {
	IndentationText,
	Project,
	QuoteKind,
	type SourceFile,
	VariableDeclarationKind,
	type WriterFunction,
} from 'ts-morph';

// Inline type definitions to avoid cross-package resolution issues during build
// These match the types from @foxen/config
interface RouteCondition {
	type: 'header' | 'cookie' | 'host' | 'query';
	key: string;
	value?: string;
}

interface NextRedirect {
	source: string;
	destination: string;
	permanent: boolean;
	basePath?: false;
	locale?: false;
	has?: RouteCondition[];
	missing?: RouteCondition[];
}

interface NextRewrite {
	source: string;
	destination: string;
	basePath?: false;
	locale?: false;
	has?: RouteCondition[];
	missing?: RouteCondition[];
}

interface NextHeader {
	source: string;
	headers: Array<{ key: string; value: string }>;
	basePath?: false;
	locale?: false;
	has?: RouteCondition[];
	missing?: RouteCondition[];
}

interface NextRewritesConfig {
	beforeFiles?: NextRewrite[];
	afterFiles?: NextRewrite[];
	fallback?: NextRewrite[];
}

interface ResolvedNextConfig {
	basePath: string;
	trailingSlash: boolean;
	redirects: NextRedirect[];
	rewrites: NextRewritesConfig;
	headers: NextHeader[];
}

/**
 * Options for config generation
 */
export interface ConfigGenOptions {
	/** Custom header comment */
	header?: string;
	/** Whether to inline rules or import them */
	inlineRules?: boolean;
	/** Path to config file if not inlining */
	configPath?: string;
}

/**
 * Generated config output
 */
export interface GeneratedConfig {
	/** config.ts content */
	content: string;
}

const DEFAULT_HEADER =
	'// Generated by @foxen/compiler - DO NOT EDIT\n// next.config.ts integration';

/**
 * Create a new ts-morph project with consistent settings
 */
function createProject(): Project {
	return new Project({
		manipulationSettings: {
			indentationText: IndentationText.Tab,
			quoteKind: QuoteKind.Double,
			useTrailingCommas: true,
		},
	});
}

/**
 * Check if rewrites config has any rules
 */
function hasAnyRewrites(rewrites: NextRewritesConfig | undefined): boolean {
	if (!rewrites) return false;
	if (Array.isArray(rewrites)) return rewrites.length > 0;
	return Boolean(
		(rewrites.beforeFiles && rewrites.beforeFiles.length > 0) ||
			(rewrites.afterFiles && rewrites.afterFiles.length > 0) ||
			(rewrites.fallback && rewrites.fallback.length > 0),
	);
}

/**
 * Writer function to serialize a redirect rule
 */
function writeRedirect(redirect: NextRedirect): WriterFunction {
	return (writer) => {
		writer.block(() => {
			writer.writeLine(`source: "${redirect.source}",`);
			writer.writeLine(`destination: "${redirect.destination}",`);
			writer.writeLine(`permanent: ${redirect.permanent},`);
			if (redirect.basePath !== undefined) {
				writer.writeLine(`basePath: ${redirect.basePath},`);
			}
			if (redirect.locale !== undefined) {
				writer.writeLine(`locale: ${redirect.locale},`);
			}
			if (redirect.has && redirect.has.length > 0) {
				writer.write('has: ');
				writeConditionArray(redirect.has)(writer);
				writer.write(',').newLine();
			}
			if (redirect.missing && redirect.missing.length > 0) {
				writer.write('missing: ');
				writeConditionArray(redirect.missing)(writer);
				writer.write(',').newLine();
			}
		});
	};
}

/**
 * Writer function to serialize a rewrite rule
 */
function writeRewrite(rewrite: NextRewrite): WriterFunction {
	return (writer) => {
		writer.block(() => {
			writer.writeLine(`source: "${rewrite.source}",`);
			writer.writeLine(`destination: "${rewrite.destination}",`);
			if (rewrite.basePath !== undefined) {
				writer.writeLine(`basePath: ${rewrite.basePath},`);
			}
			if (rewrite.locale !== undefined) {
				writer.writeLine(`locale: ${rewrite.locale},`);
			}
			if (rewrite.has && rewrite.has.length > 0) {
				writer.write('has: ');
				writeConditionArray(rewrite.has)(writer);
				writer.write(',').newLine();
			}
			if (rewrite.missing && rewrite.missing.length > 0) {
				writer.write('missing: ');
				writeConditionArray(rewrite.missing)(writer);
				writer.write(',').newLine();
			}
		});
	};
}

/**
 * Writer function to serialize a header rule
 */
function writeHeader(header: NextHeader): WriterFunction {
	return (writer) => {
		writer.block(() => {
			writer.writeLine(`source: "${header.source}",`);
			writer.write('headers: ');
			writer.write('[');
			header.headers.forEach((h, i) => {
				if (i > 0) writer.write(', ');
				writer.write(`{ key: "${h.key}", value: "${h.value}" }`);
			});
			writer.write('],').newLine();
			if (header.basePath !== undefined) {
				writer.writeLine(`basePath: ${header.basePath},`);
			}
			if (header.locale !== undefined) {
				writer.writeLine(`locale: ${header.locale},`);
			}
			if (header.has && header.has.length > 0) {
				writer.write('has: ');
				writeConditionArray(header.has)(writer);
				writer.write(',').newLine();
			}
			if (header.missing && header.missing.length > 0) {
				writer.write('missing: ');
				writeConditionArray(header.missing)(writer);
				writer.write(',').newLine();
			}
		});
	};
}

/**
 * Writer function to serialize a condition array
 */
function writeConditionArray(conditions: RouteCondition[]): WriterFunction {
	return (writer) => {
		writer.write('[');
		conditions.forEach((cond, i) => {
			if (i > 0) writer.write(', ');
			writer.write(`{ type: "${cond.type}", key: "${cond.key}"`);
			if (cond.value !== undefined) {
				writer.write(`, value: "${cond.value}"`);
			}
			writer.write(' }');
		});
		writer.write(']');
	};
}

/**
 * Add redirects variable declaration to source file
 */
function addRedirectsVariable(sourceFile: SourceFile, redirects: NextRedirect[]): void {
	sourceFile.addVariableStatement({
		declarationKind: VariableDeclarationKind.Const,
		declarations: [
			{
				name: 'redirects',
				initializer: (writer) => {
					writer.write('[').newLine();
					redirects.forEach((redirect, i) => {
						writer.indent(() => {
							writeRedirect(redirect)(writer);
							if (i < redirects.length - 1) writer.write(',');
							writer.newLine();
						});
					});
					writer.write('] as const');
				},
			},
		],
	});
}

/**
 * Add rewrites variable declaration to source file
 */
function addRewritesVariable(sourceFile: SourceFile, rewrites: NextRewritesConfig): void {
	sourceFile.addVariableStatement({
		declarationKind: VariableDeclarationKind.Const,
		declarations: [
			{
				name: 'rewrites',
				initializer: (writer) => {
					if (Array.isArray(rewrites)) {
						writer.write('[').newLine();
						rewrites.forEach((rewrite, i) => {
							writer.indent(() => {
								writeRewrite(rewrite)(writer);
								if (i < rewrites.length - 1) writer.write(',');
								writer.newLine();
							});
						});
						writer.write(']');
					} else {
						writer.block(() => {
							if (rewrites.beforeFiles && rewrites.beforeFiles.length > 0) {
								writer.write('beforeFiles: [').newLine();
								rewrites.beforeFiles.forEach((rewrite, i) => {
									writer.indent(() => {
										writeRewrite(rewrite)(writer);
										if (rewrites.beforeFiles) {
											if (i < rewrites.beforeFiles?.length - 1) writer.write(',');
										}
										writer.newLine();
									});
								});
								writer.writeLine('],');
							}
							if (rewrites.afterFiles && rewrites.afterFiles.length > 0) {
								writer.write('afterFiles: [').newLine();
								rewrites.afterFiles.forEach((rewrite, i) => {
									writer.indent(() => {
										writeRewrite(rewrite)(writer);
										if (rewrites.afterFiles) {
											if (i < rewrites.afterFiles?.length - 1) writer.write(',');
										}
										writer.newLine();
									});
								});
								writer.writeLine('],');
							}
							if (rewrites.fallback && rewrites.fallback.length > 0) {
								writer.write('fallback: [').newLine();
								rewrites.fallback.forEach((rewrite, i) => {
									writer.indent(() => {
										writeRewrite(rewrite)(writer);
										if (rewrites.fallback) {
											if (i < rewrites.fallback?.length - 1) writer.write(',');
										}
										writer.newLine();
									});
								});
								writer.writeLine('],');
							}
						});
					}
				},
			},
		],
	});
}

/**
 * Add headers variable declaration to source file
 */
function addHeadersVariable(sourceFile: SourceFile, headers: NextHeader[]): void {
	sourceFile.addVariableStatement({
		declarationKind: VariableDeclarationKind.Const,
		declarations: [
			{
				name: 'headers',
				initializer: (writer) => {
					writer.write('[').newLine();
					headers.forEach((header, i) => {
						writer.indent(() => {
							writeHeader(header)(writer);
							if (i < headers.length - 1) writer.write(',');
							writer.newLine();
						});
					});
					writer.write('] as const');
				},
			},
		],
	});
}

/**
 * Add the applyConfig function to source file
 */
function addApplyConfigFunction(sourceFile: SourceFile, config: ResolvedNextConfig): void {
	const hasRedirects = config.redirects && config.redirects.length > 0;
	const hasRewrites = hasAnyRewrites(config.rewrites);
	const hasHeaders = config.headers && config.headers.length > 0;
	const hasAnyConfig = hasRedirects || hasRewrites || hasHeaders;

	// Build JSDoc
	const jsdocParts = ['Apply next.config.ts settings to an Elysia app', '', 'Features enabled:'];
	if (hasRedirects) jsdocParts.push(`- Redirects (${config.redirects.length} rules)`);
	if (hasRewrites) jsdocParts.push('- Rewrites');
	if (hasHeaders) jsdocParts.push(`- Custom headers (${config.headers.length} rules)`);
	if (!hasAnyConfig) jsdocParts.push('- (none configured)');

	sourceFile.addFunction({
		name: 'applyConfig',
		isExported: true,
		typeParameters: [{ name: 'T', constraint: 'Elysia' }],
		parameters: [{ name: 'app', type: 'T' }],
		returnType: 'T',
		docs: [{ description: jsdocParts.join('\n') }],
		statements: (writer) => {
			if (!hasAnyConfig) {
				writer.writeLine('// No config rules to apply');
				writer.writeLine('return app;');
				return;
			}

			writer.write('return app');

			// Add onRequest for redirects and rewrites
			if (hasRedirects || hasRewrites) {
				writer.newLine().indent(() => {
					writer.write('.onRequest(({ request, set }) => ');
					writer.block(() => {
						writer.writeLine('const url = new URL(request.url);');
						writer.writeLine('const pathname = url.pathname;');
						writer.blankLine();

						if (hasRedirects) {
							writer.writeLine('// Check redirects');
							writer.writeLine('const redirectResult = processRedirects(pathname, redirects);');
							writer.write('if (redirectResult) ').block(() => {
								writer.writeLine('set.status = redirectResult.statusCode;');
								writer.writeLine('set.headers["Location"] = redirectResult.destination;');
								writer.write('return new Response(null, ').block(() => {
									writer.writeLine('status: redirectResult.statusCode,');
									writer.writeLine('headers: { Location: redirectResult.destination },');
								});
								writer.write(');');
							});
						}

						if (hasRewrites) {
							if (hasRedirects) writer.blankLine();
							writer.writeLine('// Check rewrites');
							writer.writeLine('const rewriteResult = processRewrites(pathname, rewrites);');
							writer.write('if (rewriteResult) ').block(() => {
								writer.writeLine('// Store rewrite destination for route handler');
								writer.writeLine('(request as any).__foxenRewrite = rewriteResult.destination;');
							});
						}
					});
					writer.write(')');
				});
			}

			// Add onAfterHandle for headers
			if (hasHeaders) {
				writer.newLine().indent(() => {
					writer.write('.onAfterHandle(({ request, set }) => ');
					writer.block(() => {
						writer.writeLine('const url = new URL(request.url);');
						writer.writeLine('const pathname = url.pathname;');
						writer.blankLine();
						writer.writeLine('// Apply custom headers');
						writer.writeLine('const headerResult = processHeaders(pathname, headers);');
						writer.write('if (headerResult && headerResult.headers.length > 0) ').block(() => {
							writer.write('for (const { key, value } of headerResult.headers) ').block(() => {
								writer.writeLine('set.headers[key] = value;');
							});
						});
					});
					writer.write(')');
				});
			}

			writer.write(' as T;');
		},
	});
}

/**
 * Generate config integration file from next.config
 */
export function generateConfigFile(
	nextConfig: ResolvedNextConfig,
	options: ConfigGenOptions = {},
): GeneratedConfig {
	const project = createProject();
	const sourceFile = project.createSourceFile('config.ts', '', { overwrite: true });

	// Add header comment
	const header = options.header ?? DEFAULT_HEADER;
	sourceFile.insertStatements(0, header);

	// Add imports
	sourceFile.addImportDeclaration({
		moduleSpecifier: 'elysia',
		namedImports: ['Elysia'],
	});

	const configImports: string[] = [];
	const hasRedirects = nextConfig.redirects && nextConfig.redirects.length > 0;
	const hasRewrites = hasAnyRewrites(nextConfig.rewrites);
	const hasHeaders = nextConfig.headers && nextConfig.headers.length > 0;

	if (hasRedirects) configImports.push('processRedirects');
	if (hasRewrites) configImports.push('processRewrites');
	if (hasHeaders) configImports.push('processHeaders');

	if (configImports.length > 0) {
		sourceFile.addImportDeclaration({
			moduleSpecifier: '@foxen/config',
			namedImports: configImports,
		});
	}

	// Add blank line after imports
	sourceFile.addStatements('');

	// Add data variables if inlining
	if (options.inlineRules !== false) {
		if (hasRedirects) {
			addRedirectsVariable(sourceFile, nextConfig.redirects);
			sourceFile.addStatements('');
		}
		if (hasRewrites) {
			addRewritesVariable(sourceFile, nextConfig.rewrites);
			sourceFile.addStatements('');
		}
		if (hasHeaders) {
			addHeadersVariable(sourceFile, nextConfig.headers);
			sourceFile.addStatements('');
		}
	}

	// Add applyConfig function
	addApplyConfigFunction(sourceFile, nextConfig);

	// Add basePath export if set
	if (nextConfig.basePath && nextConfig.basePath !== '') {
		sourceFile.addStatements('');
		sourceFile.addVariableStatement({
			isExported: true,
			declarationKind: VariableDeclarationKind.Const,
			declarations: [
				{
					name: 'basePath',
					initializer: `"${nextConfig.basePath}"`,
				},
			],
			docs: [{ description: 'Base path from next.config' }],
		});
	}

	return {
		content: sourceFile.getFullText(),
	};
}

/**
 * Generate a minimal config file when no next.config features are used
 */
export function generateEmptyConfigFile(options: ConfigGenOptions = {}): GeneratedConfig {
	const project = createProject();
	const sourceFile = project.createSourceFile('config.ts', '', { overwrite: true });

	// Add header
	const header = options.header ?? DEFAULT_HEADER;
	sourceFile.insertStatements(0, header);

	// Add import
	sourceFile.addImportDeclaration({
		moduleSpecifier: 'elysia',
		namedImports: ['Elysia'],
	});

	sourceFile.addStatements('');

	// Add empty applyConfig function
	sourceFile.addFunction({
		name: 'applyConfig',
		isExported: true,
		typeParameters: [{ name: 'T', constraint: 'Elysia' }],
		parameters: [{ name: 'app', type: 'T' }],
		returnType: 'T',
		docs: [
			{
				description: 'Apply config to an Elysia app\n\nNo next.config.ts features are configured.',
			},
		],
		statements: 'return app;',
	});

	return {
		content: sourceFile.getFullText(),
	};
}
