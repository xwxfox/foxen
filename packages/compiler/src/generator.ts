import {
	type CodeBlockWriter,
	IndentationText,
	Project,
	QuoteKind,
	type SourceFile,
	VariableDeclarationKind,
} from 'ts-morph';
import type {
	AnalysisResult,
	AnalyzedMiddleware,
	AnalyzedRoute,
	GeneratedFile,
	GeneratedOutput,
	GeneratorOptions,
	RouteTransformer,
} from './types.js';

/**
 * Default generator options
 */
const defaultOptions: Required<GeneratorOptions> = {
	outputPath: './generated',
	format: 'ts',
	sourceMap: false,
	minify: false,
	moduleFormat: 'esm',
	header: '// Generated by @foxen/compiler - DO NOT EDIT',
	routesAlias: '@/app',
	inlineHandlers: false,
	generateBarrel: true,
	elysiaInstanceName: 'app',
	useGroups: true,
	basePath: '/api',
};

/**
 * Code generator class
 */
export class CodeGenerator {
	private project: Project;
	private options: Required<GeneratorOptions>;
	private transformers: RouteTransformer[] = [];

	constructor(options: Partial<GeneratorOptions> = {}) {
		this.options = { ...defaultOptions, ...options };

		this.project = new Project({
			manipulationSettings: {
				indentationText: IndentationText.Tab,
				quoteKind: QuoteKind.Double,
				useTrailingCommas: true,
			},
		});
	}

	/**
	 * Add a custom transformer
	 */
	addTransformer(transformer: RouteTransformer): this {
		this.transformers.push(transformer);
		return this;
	}

	/**
	 * Generate code from analysis result
	 */
	async generate(analysis: AnalysisResult): Promise<GeneratedOutput> {
		const files: GeneratedFile[] = [];

		// Generate main router file
		const routerFile = this.generateRouterFile(analysis);
		files.push({
			path: `router.${this.options.format}`,
			content: routerFile,
			type: 'router',
		});

		// Generate type definitions if outputting JS
		if (this.options.format === 'js') {
			const types = this.generateTypeDefinitions(analysis);
			files.push({
				path: 'router.d.ts',
				content: types,
				type: 'types',
			});
		}

		// Generate barrel export if enabled
		if (this.options.generateBarrel) {
			const barrel = this.generateBarrelExport(files);
			files.push({
				path: `index.${this.options.format}`,
				content: barrel,
				type: 'barrel',
			});
		}

		return {
			routerCode: routerFile,
			typeDefinitions:
				this.options.format === 'js' ? files.find((f) => f.type === 'types')?.content : undefined,
			files,
		};
	}

	/**
	 * Generate the main router file
	 */
	private generateRouterFile(analysis: AnalysisResult): string {
		const sourceFile = this.project.createSourceFile('router.ts', '', { overwrite: true });

		// Add header comment
		if (this.options.header) {
			sourceFile.addStatements(this.options.header);
			sourceFile.addStatements('');
		}

		// Add imports
		this.addImports(sourceFile, analysis);

		// Add route imports
		this.addRouteImports(sourceFile, analysis.routes);

		// Generate middleware setup if present
		if (analysis.middleware.length > 0) {
			this.addMiddlewareImports(sourceFile, analysis.middleware);
		}

		sourceFile.addStatements('');

		// Generate the router factory function
		this.generateRouterFactory(sourceFile, analysis);

		// Generate standalone app export
		this.generateStandaloneApp(sourceFile);

		return sourceFile.getFullText();
	}

	/**
	 * Add framework imports
	 */
	private addImports(sourceFile: SourceFile, analysis: AnalysisResult): void {
		// Elysia import
		sourceFile.addImportDeclaration({
			moduleSpecifier: 'elysia',
			namedImports: ['Elysia'],
		});

		// Core imports
		const coreImports = ['NextRequest', 'NextResponse'];

		// Check if any route uses specific features
		const _needsCookies = analysis.routes.some((r) =>
			r.imports.some((i) => i.namedImports.some((n) => n.name === 'cookies')),
		);

		sourceFile.addImportDeclaration({
			moduleSpecifier: '@foxen/core',
			namedImports: coreImports,
		});

		// Adapter imports
		sourceFile.addImportDeclaration({
			moduleSpecifier: '@foxen/adapter',
			namedImports: ['defaultAdapter', 'simpleAdapter'],
		});
	}

	/**
	 * Add route file imports
	 */
	private addRouteImports(sourceFile: SourceFile, routes: AnalyzedRoute[]): void {
		sourceFile.addStatements('\n// Route handlers');

		for (const route of routes) {
			const importName = this.getRouteImportName(route);
			const importPath = this.getRouteImportPath(route);

			const namedImports = route.handlers.map((h) => ({
				name: h.exportName,
				alias: `${importName}_${h.method}`,
			}));

			sourceFile.addImportDeclaration({
				moduleSpecifier: importPath,
				namedImports,
			});
		}
	}

	/**
	 * Add middleware imports
	 */
	private addMiddlewareImports(sourceFile: SourceFile, middleware: AnalyzedMiddleware[]): void {
		sourceFile.addStatements('\n// Middleware');

		for (let i = 0; i < middleware.length; i++) {
			const mw = middleware[i];
			if (!mw) continue;
			const importPath = this.getMiddlewareImportPath(mw);

			sourceFile.addImportDeclaration({
				moduleSpecifier: importPath,
				namedImports: [
					{ name: 'middleware', alias: `middleware_${i}` },
					{ name: 'config', alias: `middlewareConfig_${i}` },
				],
			});
		}
	}

	/**
	 * Generate the router factory function
	 */
	private generateRouterFactory(sourceFile: SourceFile, analysis: AnalysisResult): void {
		const { routes, middleware } = analysis;
		const { elysiaInstanceName, basePath, useGroups } = this.options;

		// Create the factory function
		sourceFile.addFunction({
			name: 'createRouter',
			isExported: true,
			parameters: [
				{
					name: 'options',
					type: '{ basePath?: string }',
					initializer: '{}',
				},
			],
			returnType: 'Elysia',
			statements: (writer) => {
				writer.writeLine(`const base = options.basePath ?? "${basePath}";`);
				writer.blankLine();

				writer.writeLine(`const ${elysiaInstanceName} = new Elysia({ prefix: base })`);

				// Add middleware setup
				if (middleware.length > 0) {
					this.writeMiddlewareSetup(writer, middleware);
				}

				// Group routes by path prefix if enabled
				if (useGroups) {
					const groups = this.groupRoutesByPrefix(routes);
					this.writeGroupedRoutes(writer, groups);
				} else {
					this.writeRoutes(writer, routes);
				}

				writer.write(';');
				writer.blankLine();
				writer.writeLine(`return ${elysiaInstanceName};`);
			},
		});
	}

	/**
	 * Write middleware setup
	 */
	private writeMiddlewareSetup(writer: CodeBlockWriter, middleware: AnalyzedMiddleware[]): void {
		writer.indent(() => {
			writer.writeLine('.onBeforeHandle(async ({ request, set }) => {');
			writer.indent(() => {
				for (let i = 0; i < middleware.length; i++) {
					writer.writeLine(`// Middleware ${i + 1}`);
					writer.writeLine(`const result_${i} = await middleware_${i}(new NextRequest(request));`);
					writer.writeLine(`if (result_${i}) {`);
					writer.indent(() => {
						writer.writeLine(`set.status = result_${i}.status;`);
						writer.writeLine(`return result_${i};`);
					});
					writer.writeLine('}');
				}
			});
			writer.writeLine('})');
		});
	}

	/**
	 * Group routes by their path prefix
	 */
	private groupRoutesByPrefix(routes: AnalyzedRoute[]): Map<string, AnalyzedRoute[]> {
		const groups = new Map<string, AnalyzedRoute[]>();

		for (const route of routes) {
			// Get first path segment as group
			const parts = route.elysiaPath.split('/').filter(Boolean);
			const prefix = parts.length > 0 ? `/${parts[0]}` : '/';

			const existing = groups.get(prefix) ?? [];
			existing.push(route);
			groups.set(prefix, existing);
		}

		return groups;
	}

	/**
	 * Write grouped routes
	 */
	private writeGroupedRoutes(writer: CodeBlockWriter, groups: Map<string, AnalyzedRoute[]>): void {
		for (const [prefix, routes] of groups) {
			const firstRoute = routes[0];
			if (routes.length === 1 && firstRoute && firstRoute.elysiaPath === prefix) {
				// Single route at this prefix, no need for group
				this.writeRoute(writer, firstRoute);
			} else {
				// Multiple routes, use group
				writer.indent(() => {
					writer.writeLine(`.group("${prefix}", (group) => group`);
					writer.indent(() => {
						for (const route of routes) {
							// Adjust path to be relative to group
							const relativePath = route.elysiaPath.slice(prefix.length) || '/';
							this.writeRoute(writer, route, relativePath);
						}
					});
					writer.writeLine(')');
				});
			}
		}
	}

	/**
	 * Write all routes without grouping
	 */
	private writeRoutes(writer: CodeBlockWriter, routes: AnalyzedRoute[]): void {
		for (const route of routes) {
			this.writeRoute(writer, route);
		}
	}

	/**
	 * Write a single route
	 */
	private writeRoute(writer: CodeBlockWriter, route: AnalyzedRoute, pathOverride?: string): void {
		const importName = this.getRouteImportName(route);
		const path = pathOverride ?? route.elysiaPath;

		for (const handler of route.handlers) {
			const method = handler.method.toLowerCase();
			const handlerRef = `${importName}_${handler.method}`;

			writer.indent(() => {
				writer.writeLine(`.${method}("${path}", async (ctx) => {`);
				writer.indent(() => {
					// Create NextRequest
					writer.writeLine('const nextRequest = new NextRequest(ctx.request, {');
					writer.indent(() => {
						if (route.pathParams.length > 0) {
							writer.writeLine('params: ctx.params,');
						}
					});
					writer.writeLine('});');
					writer.blankLine();

					// Call handler
					writer.writeLine(`const response = await ${handlerRef}(nextRequest, {`);
					writer.indent(() => {
						writer.writeLine('params: Promise.resolve(ctx.params),');
					});
					writer.writeLine('});');
					writer.blankLine();

					// Return response
					writer.writeLine('return response;');
				});
				writer.writeLine('})');
			});
		}
	}

	/**
	 * Generate standalone app export
	 */
	private generateStandaloneApp(sourceFile: SourceFile): void {
		sourceFile.addStatements('\n// Standalone app export');

		sourceFile.addVariableStatement({
			declarationKind: VariableDeclarationKind.Const,
			isExported: true,
			declarations: [
				{
					name: 'router',
					initializer: 'createRouter()',
				},
			],
		});
	}

	/**
	 * Get import name for a route
	 */
	private getRouteImportName(route: AnalyzedRoute): string {
		// Create a valid identifier from the path
		return (
			route.elysiaPath
				.replace(/^\//, '')
				.replace(/[/:*]/g, '_')
				.replace(/-/g, '_')
				.replace(/__+/g, '_')
				.replace(/_$/, '') || 'root'
		);
	}

	/**
	 * Get import path for a route
	 */
	private getRouteImportPath(route: AnalyzedRoute): string {
		// Use the alias if configured
		const { routesAlias } = this.options;

		if (routesAlias) {
			// Convert relative path to alias path
			const aliasPath = route.relativePath
				.replace(/\\/g, '/')
				.replace(/\.tsx?$/, '')
				.replace(/\/route$/, '');
			return `${routesAlias}/${aliasPath}/route`;
		}

		// Use relative path
		return `./${route.relativePath.replace(/\.tsx?$/, '')}`;
	}

	/**
	 * Get import path for middleware
	 */
	private getMiddlewareImportPath(_mw: AnalyzedMiddleware): string {
		const { routesAlias } = this.options;

		if (routesAlias) {
			return `${routesAlias}/middleware`;
		}

		return './middleware';
	}

	/**
	 * Generate type definitions
	 */
	private generateTypeDefinitions(_analysis: AnalysisResult): string {
		const sourceFile = this.project.createSourceFile('router.d.ts', '', { overwrite: true });

		sourceFile.addStatements('// Type definitions for generated router');
		sourceFile.addStatements('');

		sourceFile.addImportDeclaration({
			moduleSpecifier: 'elysia',
			namedImports: ['Elysia'],
			isTypeOnly: true,
		});

		sourceFile.addStatements('');

		// Export router type
		sourceFile.addTypeAlias({
			name: 'RouterOptions',
			isExported: true,
			type: '{ basePath?: string }',
		});

		sourceFile.addStatements('');

		sourceFile.addStatements(
			'export declare function createRouter(options?: RouterOptions): Elysia;',
		);
		sourceFile.addStatements('export declare const router: Elysia;');

		return sourceFile.getFullText();
	}

	/**
	 * Generate barrel export file
	 */
	private generateBarrelExport(_files: GeneratedFile[]): string {
		const sourceFile = this.project.createSourceFile('index.ts', '', { overwrite: true });

		if (this.options.header) {
			sourceFile.addStatements(this.options.header);
			sourceFile.addStatements('');
		}

		// Export from router
		sourceFile.addExportDeclaration({
			moduleSpecifier: './router',
		});

		// Re-export core types
		sourceFile.addExportDeclaration({
			moduleSpecifier: '@foxen/core',
			namedExports: ['NextRequest', 'NextResponse'],
		});

		return sourceFile.getFullText();
	}
}

/**
 * Generate code from analysis
 */
export async function generateCode(
	analysis: AnalysisResult,
	options?: Partial<GeneratorOptions>,
): Promise<GeneratedOutput> {
	const generator = new CodeGenerator(options);
	return generator.generate(analysis);
}

/**
 * Generate and write to disk
 */
export async function generateAndWrite(
	analysis: AnalysisResult,
	options: Partial<GeneratorOptions> & { outputPath: string },
): Promise<void> {
	const generator = new CodeGenerator(options);
	const output = await generator.generate(analysis);

	const { mkdir, writeFile } = await import('node:fs/promises');
	const { join } = await import('node:path');

	await mkdir(options.outputPath, { recursive: true });

	for (const file of output.files) {
		const filePath = join(options.outputPath, file.path);
		await writeFile(filePath, file.content, 'utf-8');
	}
}
