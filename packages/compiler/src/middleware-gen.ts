import {
	IndentationText,
	Project,
	QuoteKind,
	type SourceFile,
	VariableDeclarationKind,
	type WriterFunction,
} from 'ts-morph';

// Inline type definitions to avoid cross-package resolution issues during build
// These match the types from @foxen/middleware

interface RouteCondition {
	type: 'header' | 'cookie' | 'host' | 'query';
	key: string;
	value?: string;
}

/** Normalized matcher with compiled regex */
interface NormalizedMatcher {
	source: string;
	regex: RegExp;
	has?: RouteCondition[];
	missing?: RouteCondition[];
}

/** Middleware type identifier */
type MiddlewareType = 'middleware' | 'proxy';

/** Loaded and normalized middleware */
interface LoadedMiddleware {
	type: MiddlewareType;
	path: string;
	handler: (request: Request) => Promise<Response | undefined> | Response | undefined;
	matchers: NormalizedMatcher[];
}

/**
 * Options for middleware generation
 */
export interface MiddlewareGenOptions {
	/** Custom header comment */
	header?: string;
	/** Path to middleware file (for import) */
	middlewarePath?: string;
	/** Whether the middleware is async */
	isAsync?: boolean;
}

/**
 * Generated middleware output
 */
export interface GeneratedMiddleware {
	/** middleware.ts content */
	content: string;
}

const DEFAULT_HEADER = '// Generated by @foxen/compiler - DO NOT EDIT\n// Middleware integration';

/**
 * Create a new ts-morph project with consistent settings
 */
function createProject(): Project {
	return new Project({
		manipulationSettings: {
			indentationText: IndentationText.Tab,
			quoteKind: QuoteKind.Double,
			useTrailingCommas: true,
		},
	});
}

/**
 * Writer function to serialize a single matcher
 */
function writeMatcher(matcher: NormalizedMatcher): WriterFunction {
	return (writer) => {
		writer.block(() => {
			writer.writeLine(`source: "${matcher.source}",`);
			writer.writeLine(`regex: ${matcher.regex.toString()},`);
			if (matcher.has && matcher.has.length > 0) {
				writer.write('has: ');
				writeConditionArray(matcher.has)(writer);
				writer.write(',').newLine();
			}
			if (matcher.missing && matcher.missing.length > 0) {
				writer.write('missing: ');
				writeConditionArray(matcher.missing)(writer);
				writer.write(',').newLine();
			}
		});
	};
}

/**
 * Writer function to serialize a condition array
 */
function writeConditionArray(conditions: RouteCondition[]): WriterFunction {
	return (writer) => {
		writer.write('[');
		conditions.forEach((cond, i) => {
			if (i > 0) writer.write(', ');
			writer.write(`{ type: "${cond.type}", key: "${cond.key}"`);
			if (cond.value !== undefined) {
				writer.write(`, value: "${cond.value}"`);
			}
			writer.write(' }');
		});
		writer.write(']');
	};
}

/**
 * Add matchers variable declaration to source file
 */
function addMatchersVariable(sourceFile: SourceFile, matchers: NormalizedMatcher[]): void {
	sourceFile.addVariableStatement({
		declarationKind: VariableDeclarationKind.Const,
		declarations: [
			{
				name: 'matchers',
				initializer: (writer) => {
					writer.write('[').newLine();
					matchers.forEach((matcher, i) => {
						writer.indent(() => {
							writeMatcher(matcher)(writer);
							if (i < matchers.length - 1) writer.write(',');
							writer.newLine();
						});
					});
					writer.write(']');
				},
			},
		],
		docs: [{ description: 'Compiled middleware matchers' }],
	});
}

/**
 * Add the applyMiddleware function to source file
 */
function addApplyMiddlewareFunction(sourceFile: SourceFile, middleware: LoadedMiddleware): void {
	const hasMatchers = middleware.matchers.length > 0;

	// Build JSDoc
	const jsdocParts = [
		'Apply middleware to an Elysia app',
		'',
		`Middleware type: ${middleware.type}`,
	];
	if (hasMatchers) {
		jsdocParts.push(`Matchers: ${middleware.matchers.length} pattern(s)`);
	} else {
		jsdocParts.push('Matchers: All routes (no specific matchers)');
	}

	sourceFile.addFunction({
		name: 'applyMiddleware',
		isExported: true,
		typeParameters: [{ name: 'T', constraint: 'Elysia' }],
		parameters: [{ name: 'app', type: 'T' }],
		returnType: 'T',
		docs: [{ description: jsdocParts.join('\n') }],
		statements: (writer) => {
			writer.write('return app');
			writer.newLine().indent(() => {
				writer.write('.onRequest(async ({ request, set }) => ');
				writer.block(() => {
					writer.writeLine('const url = new URL(request.url);');
					writer.writeLine('const pathname = url.pathname;');
					writer.blankLine();

					// Check matchers if present
					if (hasMatchers) {
						writer.writeLine('// Check if middleware should run for this path');
						writer.write('if (!shouldRunMiddleware(pathname, matchers)) ').block(() => {
							writer.writeLine('return;');
						});
						writer.blankLine();
					}

					writer.writeLine('// Create NextRequest for middleware');
					writer.writeLine('const nextRequest = new NextRequest(request);');
					writer.blankLine();

					writer.write('try ').block(() => {
						writer.writeLine('// Execute middleware');
						writer.writeLine(
							'const result = await executeMiddleware(nextRequest, middlewareHandler);',
						);
						writer.blankLine();

						writer.writeLine('// Handle middleware response');
						writer.write('if (!result.continue) ').block(() => {
							writer.writeLine('// Middleware returned a response, short-circuit');
							writer.writeLine('return result.response;');
						});
						writer.blankLine();

						writer.writeLine('// Apply any headers set by middleware');
						writer.write('if (result.headers) ').block(() => {
							writer
								.write('for (const [key, value] of Object.entries(result.headers)) ')
								.block(() => {
									writer.writeLine('set.headers[key] = value;');
								});
						});
						writer.blankLine();

						writer.writeLine('// Handle rewrites');
						writer.write('if (result.rewrite) ').block(() => {
							writer.writeLine('(request as any).__foxenRewrite = result.rewrite;');
						});
					});

					writer.write(' catch (error) ').block(() => {
						writer.writeLine(
							'console.error("[foxen:middleware] Error executing middleware:", error);',
						);
						writer.writeLine('throw error;');
					});
				});
				writer.write(')');
			});
			writer.write(' as T;');
		},
	});
}

/**
 * Generate middleware integration file
 */
export function generateMiddlewareFile(
	middleware: LoadedMiddleware,
	options: MiddlewareGenOptions = {},
): GeneratedMiddleware {
	const project = createProject();
	const sourceFile = project.createSourceFile('middleware.ts', '', { overwrite: true });

	// Add header comment
	const header = options.header ?? DEFAULT_HEADER;
	sourceFile.insertStatements(0, header);

	// Add imports
	sourceFile.addImportDeclaration({
		moduleSpecifier: 'elysia',
		namedImports: ['Elysia'],
	});

	sourceFile.addImportDeclaration({
		moduleSpecifier: '@foxen/core',
		namedImports: ['NextRequest', 'NextResponse'],
	});

	const middlewareImports = ['executeMiddleware'];
	if (middleware.matchers.length > 0) {
		middlewareImports.unshift('shouldRunMiddleware');
	}

	sourceFile.addImportDeclaration({
		moduleSpecifier: '@foxen/middleware',
		namedImports: middlewareImports,
	});

	// Import the actual middleware handler
	const middlewarePath = options.middlewarePath ?? '../middleware';
	sourceFile.addImportDeclaration({
		moduleSpecifier: middlewarePath,
		namedImports: [{ name: 'middleware', alias: 'middlewareHandler' }],
	});

	// Add blank line after imports
	sourceFile.addStatements('');

	// Add matchers variable if present
	if (middleware.matchers.length > 0) {
		addMatchersVariable(sourceFile, middleware.matchers);
		sourceFile.addStatements('');
	}

	// Add applyMiddleware function
	addApplyMiddlewareFunction(sourceFile, middleware);

	return {
		content: sourceFile.getFullText(),
	};
}

/**
 * Generate empty middleware file when no middleware exists
 */
export function generateEmptyMiddlewareFile(
	options: MiddlewareGenOptions = {},
): GeneratedMiddleware {
	const project = createProject();
	const sourceFile = project.createSourceFile('middleware.ts', '', { overwrite: true });

	// Add header
	const header = options.header ?? DEFAULT_HEADER;
	sourceFile.insertStatements(0, header);

	// Add import
	sourceFile.addImportDeclaration({
		moduleSpecifier: 'elysia',
		namedImports: ['Elysia'],
	});

	sourceFile.addStatements('');

	// Add empty applyMiddleware function
	sourceFile.addFunction({
		name: 'applyMiddleware',
		isExported: true,
		typeParameters: [{ name: 'T', constraint: 'Elysia' }],
		parameters: [{ name: 'app', type: 'T' }],
		returnType: 'T',
		docs: [{ description: 'Apply middleware to an Elysia app\n\nNo middleware configured.' }],
		statements: 'return app;',
	});

	return {
		content: sourceFile.getFullText(),
	};
}

/**
 * Generate middleware that wraps multiple middleware handlers
 */
export function generateComposedMiddlewareFile(
	middlewares: LoadedMiddleware[],
	options: MiddlewareGenOptions = {},
): GeneratedMiddleware {
	const project = createProject();
	const sourceFile = project.createSourceFile('middleware.ts', '', { overwrite: true });

	// Add header
	const header = options.header ?? DEFAULT_HEADER;
	sourceFile.insertStatements(0, header);

	// Add imports
	sourceFile.addImportDeclaration({
		moduleSpecifier: 'elysia',
		namedImports: ['Elysia'],
	});

	sourceFile.addImportDeclaration({
		moduleSpecifier: '@foxen/core',
		namedImports: ['NextRequest'],
	});

	const hasAnyMatchers = middlewares.some((mw) => mw.matchers.length > 0);
	const middlewareImports = ['executeMiddleware'];
	if (hasAnyMatchers) {
		middlewareImports.unshift('shouldRunMiddleware');
	}

	sourceFile.addImportDeclaration({
		moduleSpecifier: '@foxen/middleware',
		namedImports: middlewareImports,
	});

	// Import each middleware handler
	middlewares.forEach((mw, i) => {
		const importPath = mw.path.replace(/\.tsx?$/, '');
		sourceFile.addImportDeclaration({
			moduleSpecifier: importPath,
			namedImports: [{ name: 'middleware', alias: `middleware_${i}` }],
		});
	});

	// Add blank line after imports
	sourceFile.addStatements('');

	// Add matchers for each middleware that has them
	middlewares.forEach((mw, i) => {
		if (mw.matchers.length > 0) {
			sourceFile.addVariableStatement({
				declarationKind: VariableDeclarationKind.Const,
				declarations: [
					{
						name: `matchers_${i}`,
						initializer: (writer) => {
							writer.write('[').newLine();
							mw.matchers.forEach((matcher, j) => {
								writer.indent(() => {
									writeMatcher(matcher)(writer);
									if (j < mw.matchers.length - 1) writer.write(',');
									writer.newLine();
								});
							});
							writer.write(']');
						},
					},
				],
			});
			sourceFile.addStatements('');
		}
	});

	// Add composed applyMiddleware function
	sourceFile.addFunction({
		name: 'applyMiddleware',
		isExported: true,
		typeParameters: [{ name: 'T', constraint: 'Elysia' }],
		parameters: [{ name: 'app', type: 'T' }],
		returnType: 'T',
		docs: [{ description: `Apply ${middlewares.length} middleware(s) to an Elysia app` }],
		statements: (writer) => {
			writer.write('return app');
			writer.newLine().indent(() => {
				writer.write('.onRequest(async ({ request, set }) => ');
				writer.block(() => {
					writer.writeLine('const url = new URL(request.url);');
					writer.writeLine('const pathname = url.pathname;');
					writer.writeLine('const nextRequest = new NextRequest(request);');
					writer.blankLine();

					middlewares.forEach((mw, i) => {
						writer.writeLine(`// Middleware ${i + 1}: ${mw.type}`);

						if (mw.matchers.length > 0) {
							writer.write(`if (shouldRunMiddleware(pathname, matchers_${i})) `).block(() => {
								writer.writeLine(
									`const result_${i} = await executeMiddleware(nextRequest, middleware_${i});`,
								);
								writer.writeLine(`if (!result_${i}.continue) return result_${i}.response;`);
								writer.writeLine(
									`if (result_${i}.headers) Object.assign(set.headers, result_${i}.headers);`,
								);
							});
						} else {
							writer.writeLine(
								`const result_${i} = await executeMiddleware(nextRequest, middleware_${i});`,
							);
							writer.writeLine(`if (!result_${i}.continue) return result_${i}.response;`);
							writer.writeLine(
								`if (result_${i}.headers) Object.assign(set.headers, result_${i}.headers);`,
							);
						}
						writer.blankLine();
					});
				});
				writer.write(')');
			});
			writer.write(' as T;');
		},
	});

	return {
		content: sourceFile.getFullText(),
	};
}
