import {
	IndentationText,
	Project,
	QuoteKind,
	type SourceFile,
	VariableDeclarationKind,
} from 'ts-morph';
import type { SchemaAnalysis } from './schema.js';
import type { AnalysisResult, AnalyzedRoute } from './types.js';

/**
 * Options for type generation
 */
export interface TypeGenOptions {
	/** Custom header comment */
	header?: string;
	/** Whether to generate a client helper */
	generateClient?: boolean;
	/** Server URL for client generation */
	serverUrl?: string;
	/** Whether to export individual route types */
	exportIndividualTypes?: boolean;
}

/**
 * Generated types output
 */
export interface GeneratedTypes {
	/** Main types.ts content */
	typesContent: string;
	/** Optional client.ts content */
	clientContent?: string;
}

const DEFAULT_HEADER =
	'// Generated by @foxen/compiler - DO NOT EDIT\n// Eden Treaty compatible types';

/**
 * Create a new ts-morph project with consistent settings
 */
function createProject(): Project {
	return new Project({
		manipulationSettings: {
			indentationText: IndentationText.Tab,
			quoteKind: QuoteKind.Double,
			useTrailingCommas: true,
		},
	});
}

/**
 * Convert a route to a valid TypeScript type name
 */
function routeToTypeName(route: AnalyzedRoute): string {
	const name = route.elysiaPath
		.split('/')
		.filter(Boolean)
		.map((segment) => {
			// Remove : prefix for params
			if (segment.startsWith(':')) {
				segment = segment.slice(1);
			}
			// Remove * prefix for catch-all
			if (segment.startsWith('*')) {
				segment = segment.slice(1) || 'CatchAll';
			}
			// Capitalize first letter
			return segment.charAt(0).toUpperCase() + segment.slice(1);
		})
		.join('');

	return `${name || 'Root'}Route`;
}

/**
 * Add App type alias to source file
 */
function addAppTypeAlias(sourceFile: SourceFile): void {
	sourceFile.addTypeAlias({
		name: 'App',
		isExported: true,
		type: 'typeof routes',
		docs: [
			{
				description: [
					'Main application type for Eden Treaty',
					'',
					'@example',
					'```typescript',
					"import { treaty } from '@elysiajs/eden';",
					"import type { App } from './generated';",
					'',
					"const api = treaty<App>('http://localhost:3000');",
					'const { data } = await api.users.get();',
					'```',
				].join('\n'),
			},
		],
	});
}

/**
 * Add individual route type aliases
 */
function addIndividualRouteTypes(sourceFile: SourceFile, routes: AnalyzedRoute[]): void {
	sourceFile.addStatements('// Individual route types');

	for (const route of routes) {
		const typeName = routeToTypeName(route);
		const methods = route.handlers.map((h) => h.method).join(' | ');

		sourceFile.addTypeAlias({
			name: typeName,
			isExported: true,
			type: `App extends Elysia<infer _, infer Routes> ? Routes["${route.elysiaPath}"] : never`,
			docs: [{ description: `Route: ${route.elysiaPath} [${methods}]` }],
		});
	}
}

/**
 * Generate type exports for Eden Treaty
 */
export function generateTypeExports(
	analysis: AnalysisResult,
	options: TypeGenOptions = {},
): GeneratedTypes {
	const project = createProject();
	const typesFile = project.createSourceFile('types.ts', '', { overwrite: true });

	// Add header
	const header = options.header ?? DEFAULT_HEADER;
	typesFile.insertStatements(0, header);

	// Import Elysia type
	typesFile.addImportDeclaration({
		moduleSpecifier: 'elysia',
		namedImports: [{ name: 'Elysia', isTypeOnly: true }],
		isTypeOnly: true,
	});

	// Import routes type
	typesFile.addImportDeclaration({
		moduleSpecifier: './routes',
		namedImports: [{ name: 'routes', isTypeOnly: true }],
		isTypeOnly: true,
	});

	typesFile.addStatements('');

	// Add App type alias
	addAppTypeAlias(typesFile);

	// Export individual route types if requested
	if (options.exportIndividualTypes && analysis.routes.length > 0) {
		typesFile.addStatements('');
		addIndividualRouteTypes(typesFile, analysis.routes);
	}

	const result: GeneratedTypes = {
		typesContent: typesFile.getFullText(),
	};

	// Generate client helper if requested
	if (options.generateClient) {
		result.clientContent = generateClientHelper(project, options);
	}

	return result;
}

/**
 * Generate a client helper file with treaty setup
 */
function generateClientHelper(project: Project, options: TypeGenOptions): string {
	const clientFile = project.createSourceFile('client.ts', '', { overwrite: true });

	const header = options.header ?? DEFAULT_HEADER;
	clientFile.insertStatements(0, header);

	// Import treaty
	clientFile.addImportDeclaration({
		moduleSpecifier: '@elysiajs/eden',
		namedImports: ['treaty'],
	});

	// Import App type
	clientFile.addImportDeclaration({
		moduleSpecifier: './types',
		namedImports: [{ name: 'App', isTypeOnly: true }],
		isTypeOnly: true,
	});

	clientFile.addStatements('');

	// Default server URL
	const serverUrl = options.serverUrl ?? 'http://localhost:3000';

	// Export configured api client
	clientFile.addVariableStatement({
		isExported: true,
		declarationKind: VariableDeclarationKind.Const,
		declarations: [
			{
				name: 'api',
				initializer: `treaty<App>("${serverUrl}")`,
			},
		],
		docs: [
			{
				description: [
					'Pre-configured API client with full type safety',
					'',
					'@example',
					'```typescript',
					'const { data, error } = await api.users.get();',
					"const { data } = await api.users({ id: '123' }).get();",
					'```',
				].join('\n'),
			},
		],
	});

	clientFile.addStatements('');

	// Export factory function
	clientFile.addFunction({
		name: 'createApi',
		isExported: true,
		parameters: [{ name: 'baseUrl', type: 'string' }],
		docs: [
			{
				description: [
					'Create a new API client with a custom base URL',
					'',
					'@param baseUrl - The base URL of the API server',
					'@returns A type-safe API client',
				].join('\n'),
			},
		],
		statements: 'return treaty<App>(baseUrl);',
	});

	clientFile.addStatements('');

	// Re-export the type
	clientFile.addStatements('// Re-export App type for convenience');
	clientFile.addExportDeclaration({
		moduleSpecifier: './types',
		namedExports: [{ name: 'App', isTypeOnly: true }],
		isTypeOnly: true,
	});

	return clientFile.getFullText();
}

/**
 * Generate route-specific types with full detail
 * This is useful for documentation or advanced type manipulation
 */
export function generateDetailedRouteTypes(
	routes: AnalyzedRoute[],
	schemas: Map<string, SchemaAnalysis>,
): string {
	const project = createProject();
	const sourceFile = project.createSourceFile('detailed-types.ts', '', { overwrite: true });

	sourceFile.addStatements('// Detailed route types with schema information');

	for (const route of routes) {
		const schema = schemas.get(route.filePath);
		const typeName = `${routeToTypeName(route)}Info`;

		// Build params type
		let paramsType: string;
		if (route.pathParams.length > 0) {
			const paramProps = route.pathParams.map((p) => `${p}: string`).join('; ');
			paramsType = `{ ${paramProps} }`;
		} else {
			paramsType = 'Record<string, never>';
		}

		// Build methods type
		const methodsType = route.handlers.map((h) => `"${h.method}"`).join(' | ') || 'never';

		sourceFile.addInterface({
			name: typeName,
			isExported: true,
			docs: [{ description: route.elysiaPath }],
			properties: [
				{ name: 'path', type: `"${route.elysiaPath}"` },
				{ name: 'params', type: paramsType },
				{ name: 'methods', type: methodsType },
				{ name: 'hasSchema', type: schema?.hasSchema ? 'true' : 'false' },
			],
		});
	}

	// Generate union of all route infos
	if (routes.length > 0) {
		sourceFile.addStatements('');
		const unionType = routes.map((r) => `${routeToTypeName(r)}Info`).join(' | ');
		sourceFile.addTypeAlias({
			name: 'AllRoutes',
			isExported: true,
			type: unionType,
			docs: [{ description: 'Union of all route types' }],
		});
	}

	return sourceFile.getFullText();
}

/**
 * Generate a manifest of all routes
 * Useful for documentation and runtime discovery
 */
export function generateRouteManifest(routes: AnalyzedRoute[]): string {
	const project = createProject();
	const sourceFile = project.createSourceFile('manifest.ts', '', { overwrite: true });

	sourceFile.addStatements('// Route manifest');

	// Build manifest array
	sourceFile.addVariableStatement({
		isExported: true,
		declarationKind: VariableDeclarationKind.Const,
		declarations: [
			{
				name: 'routeManifest',
				initializer: (writer) => {
					writer.write('[').newLine();
					routes.forEach((route, i) => {
						writer.indent(() => {
							writer.block(() => {
								writer.writeLine(`path: "${route.elysiaPath}",`);

								// Methods array
								writer.write('methods: [');
								route.handlers.forEach((h, j) => {
									if (j > 0) writer.write(', ');
									writer.write(`"${h.method}"`);
								});
								writer.write('],').newLine();

								// Params array
								writer.write('params: [');
								route.pathParams.forEach((p, j) => {
									if (j > 0) writer.write(', ');
									writer.write(`"${p}"`);
								});
								writer.write('],').newLine();

								writer.writeLine(`isCatchAll: ${route.isCatchAll},`);
								writer.writeLine(`isOptionalCatchAll: ${route.isOptionalCatchAll},`);
							});
							if (i < routes.length - 1) writer.write(',');
							writer.newLine();
						});
					});
					writer.write('] as const');
				},
			},
		],
	});

	sourceFile.addStatements('');

	// Add manifest type
	sourceFile.addTypeAlias({
		name: 'RouteManifest',
		isExported: true,
		type: 'typeof routeManifest',
	});

	return sourceFile.getFullText();
}
